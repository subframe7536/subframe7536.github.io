线程的生命周期包含5个阶段，包括：新建、就绪、运行、阻塞、销毁。

-   新建：就是刚使用new方法，new出来的线程；
    
-   就绪：就是调用的线程的start()方法后，这时候线程处于等待CPU分配资源阶段，谁先抢的CPU资源，谁开始执行;
    
-   运行：当就绪的线程被调度并获得CPU资源时，便进入运行状态，run方法定义了线程的操作和功能;
    
-   阻塞：在运行状态的时候，可能因为某些原因导致运行状态的线程变成了阻塞状态，比如sleep()、wait()之后线程就处于了阻塞状态，这个时候需要其他机制将处于阻塞状态的线程唤醒，比如调用notify或者notifyAll()方法。唤醒的线程不会立刻执行run方法，它们要再次等待CPU分配资源进入运行状态;
    
-   销毁：如果线程正常执行完毕后或线程被提前强制性的终止或出现异常导致结束，那么线程就要被销毁，释放资源;

### 新建(New)状态
```java
Thread t1 = new Thread();
```
只是在java语言层面被创建，实际没有创建
### 就绪(Runnable)状态
```java
t1.start();
```
创建线程并进入`Runnable`状态
- 只能进入运行状态或者被`JVM Crash`终止
### 运行(Running)状态
-   被转换成`Terminated`状态，比如调用 `stop()` 方法;
    
-   被转换成`Blocked`状态，比如调用了sleep, wait 方法被加入 waitSet 中；
    
-   被转换成Blocked状态，如进行 IO 阻塞操作，如查询数据库进入阻塞状态；
    
-   被转换成Blocked状态，比如获取某个锁的释放，而被加入该锁的阻塞队列中；
    
-   该线程的时间片用完，CPU 再次调度，进入Runnable状态；
    
-   线程主动调用 yield 方法，让出 CPU 资源，进入Runnable状态
### 阻塞(Block)状态
-   被转换成Terminated状态，比如调用 stop() 方法，或者是 JVM 意外 Crash;
    
-   被转换成Runnable状态，阻塞时间结束，比如读取到了数据库的数据后；
    
-   完成了指定时间的休眠，进入到Runnable状态；
    
-   正在wait中的线程，被其他线程调用notify/notifyAll方法唤醒，进入到Runnable状态；
    
-   线程获取到了想要的锁资源，进入Runnable状态；
    
-   线程在阻塞状态下被打断，如其他线程调用了interrupt方法，进入到Runnable状态；
### 终止(Terminate)状态
-   线程正常运行结束，生命周期结束；
    
-   线程运行过程中出现意外错误；
    
-   JVM 异常结束，所有的线程生命周期均被结束。

