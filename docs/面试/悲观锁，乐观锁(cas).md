# 悲观锁
独占锁，`java`中使用`synchronized`
### 缺点
- 在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延时，引起性能问题
- 一个线程持有锁会导致其他所有需要此锁的线程挂起
- 如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能风险
# 乐观锁(cas)
底层级别支持的"无锁"变量同步，在intel的CPU中，使用cmpxchg指令
### 原理
使用内存位置的值（V）、预期原值（A）和新值（B）三个变量
- 如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置更新为新值。
- 否则，处理器不做任何操作。无论哪种情况，它都会在CAS指令之前返回该位置的值。
### 特点
- CAS（Compare And Swap）比较并替换，是线程并发运行时用到的一种技术
- CAS是原子操作，保证并发安全，而不能保证并发同步
- CAS是CPU的一个指令（需要JNI调用Native方法，才能调用CPU的指令）
- CAS是非阻塞的、轻量级的乐观锁
### 使用
由于CAS是CPU指令，我们只能通过JNI与操作系统交互，关于CAS的方法都在`sun.misc.Unsafe`中，`java.util.concurrent.atomic`包下的原子类实现原子操作
### 优缺点
#### 优点
 非阻塞的轻量级的乐观锁，通过CPU指令实现，在资源竞争不激烈的情况下性能高，相比synchronized重量锁，synchronized会进行比较复杂的加锁、解锁和唤醒操作。
#### 缺点
1. ABA问题： 线程C、D；线程D将A修改为B后又修改为A，此时C线程以为A没有改变过，java的原子类AtomicStampedReference，通过**控制变量值的版本号**来保证CAS的正确性。具体解决思路就是在变量前追加上版本号，每次变量更新的时候把版本号加一，那么A - B - A就会变成1A - 2B - 3A。
2. 自旋时间过长，消耗CPU资源，如果资源竞争激烈，多线程自旋长时间消耗资源