### 分页和分段的区别

|                  | 分页                                                                                                                       | 分段                                                                                              |
| ---------------- | -------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------- |
| 目的             | 页是信息的物理单位，分页是为实现离散分配方式，以消减内存的外零头，提髙内存的利用率。                                       | 是信息的逻辑单位，它含有一组其意义相对完整的信息。分段的目的是为了能更好地满足用户的需要          |
| 长度             | 页的大小固定且由系统决定，由系统把逻辑地址划分为页号和页内地址两部分，是由机器硬件实现的，因而在系统中只能有一种大小的页面 | 段的长度不固定，决定于用户所编写的程序， 通常由编译程序在对流程序进行编译时，根据信息的性质来划分 |
| 地址空间         | 分页地址空间是一维的，即单一的线性地址空间，程序员只需利用一个记忆符，即可表示一个地址                                     | 分段地址空间是二维的，程序员在标识一个地址时，既需给出段名，又需给出段内地址                      |
| 碎片             | 有内部碎片，无外部碎片                                                                                                     | 有外部碎片，无内部碎片                                                                            |
| 共享 和 动态链接 | 不容易实现                                                                                                                 | 容易实现                                                                                          | 

### 分段式存储管理、分页式存储管理，两个的区别？

- **分段式存储管理**：分页存储管理是将一个进程的地址（逻辑地址空间）空间划分成若干个大小相等的区域，称为页，相应地，将内存空间划分成与页相同大小（为了保证页内偏移一致）的若干个物理块，称为块或页框（页架）。在为进程分配内存时，将进程中的若干页分别装入多个不相邻接的块中。
- **分页式存储管理**：在分段存储管理方式中，作业的地址空间被划分为若干个段，每个段是一组完整的逻辑信息，如有主程序段、子程序段、数据段及堆栈段等，每个段都有自己的名字，都是从零开始编址的一段连续的地址空间，各段长度是不等的。
#### 两者的区别
- 页是信息的物理单位，分页是为了实现**非连续的分配**，以便解决内存的碎片问题，或者说分页是为了由于系统管理的需要。
- 页的大小固定是由系统确定的，将逻辑地址划分为页号和页内地址是由机器硬件实现的。而段的长度是**不固定**的，决定与用户的程序长度，通常由编译程序进行编译时根据信息的性质来划分。
- 分页式存储管理的作业地址空间是一维的，分段式的存储管理的作业管理地址空间是二维的。

### 页面置换算法
#### Opt(Optimal 最佳置换算法)
选择那些永不使用的，或者是在最长时间内不再被访问的页面置换出去。（它是一种理想化的算法，性能最好，但在实际上难于实现）。
#### FIFO(First In First Out 先进先出置换算法)
该算法总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面予以淘汰。
#### LRU(Least Recently Used 最近最久未使用置换算法)
该算法是选择最近最久未使用的页面予以淘汰，系统在每个页面设置一个访问字段，用以记录这个页面自上次被访问以来所经历的时间T，当要淘汰一个页面时，选择T最大的页面。
#### NRU(Not RecentlyUsed 最近未用)
该算法为每个页面设置一位访问位，将内存中的所有页面都通过链接指针链成一个循环队列。当某页被访问时，其访问位置"1"。在选择一页淘汰时，就检查其访问位，如果是"0"，就选择该页换出；若为"1"，则重新置为"0"，暂不换出该页，在循环队列中检查下一个页面，直到访问位为"0"的页面为止。由于该算法只有一位访问位，只能用它表示该页是否已经使用过，而置换时是将未使用过的页面换出去，所以把该算法称为最近未用算法。
#### LFU(Least Frequently Used 最少使用置换算法)
该算法选择最近时期使用最少的页面作为淘汰页。
### 内存抖动现象
页面的频繁更换，导致整个系统效率急剧下降，这个现象称为内存抖动（或颠簸）。抖动一般是内存分配算法不好，内存太小引或者程序的算法不佳引起的。
### Belady现象
对有的页面置换算法，页错误率可能会随着分配帧数增加而增加。

