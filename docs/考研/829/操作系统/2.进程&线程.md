---
alias: os-进程管理
tag:
- 考研
- 829
- os
date: 2022年07月14日
---
![[大纲#进程管理]]
## 前趋图
是一个**有向无环图**，可记为DAG（DirectedAcyclic Graph），它用于描述进程之间执行的先后顺序和并发执行的状况
图中的每个结点可用来表示一个进程或程序段，乃至一条语句
![[2.进程与线程-20220715.png]]
结点间的有向边说明两个结点之间存在的偏序（Partial Order）或前趋关系（Precedence Relation），表示在Pj开始执行之前Pi必须完成。此时称Pi是Pj的**直接前趋**，而称Pj是Pi的**直接后继**。
在前趋图中，没有前趋的结点称为**初始结点**（Initial Node），没有后继的结点称为**终止结点**（Final Node）。
此外，每个结点还具有一个**重量**（Weight），表示该结点所含有的程序量或程序的执行时间。

## 顺序执行和并发执行的特点
### 顺序执行
1. 顺序性：指处理机严格地按照程序所规定的顺序执行
2. 封闭性：指程序在封闭的环境下运行，程序一旦开始执行，其执行结果不受外界因素影响
3. 可再现性：指只要程序执行时的环境和初始条件相同，结果必定相同
### 并发执行
1. 间断性：程序在并发执行时，由于它们共享系统资源，以及为完成同一项任务而相互合作，致使在这些并发执行的程序之间形成了相互制约的关系
2. 失去封闭性：当系统中存在着多个可以并发执行的程序时，系统中的各种资源将为它们所共享，而这些资源的状态也由这些程序来改变，致使其中任一程序在运行时，其环境都必然会受到其它程序的影响，如：执行顺序发生改变
3. 不可再现性：程序在并发执行时，由于失去了封闭性，也将导致其又失去可再现性
## 进程
### 概念
进程是进程实体的运行过程，是系统进行资源分配和调度（即时间片）的一个**独立单位**
### 引入目的
在多道程序环境下，允许多个程序并发执行，此时它们将失去封闭性，并具有间断性及不可再现性的特征。为此引入了进程（Process）的概念，以便更好地描述和控制程序的**并发执行**，实现操作系统的并发性和共享性（最基本的两个特性）。
### PCB
为了使参与并发执行的每个程序（含数据）都能独立地运行，必须为之配置一个专门的数据结构，称为**进程控制块**（Process Control Block, PCB）。系统利用 PCB 来描述进程的基本情况和运行状态，进而控制和管理进程。
- 进程映像：程序段、相关数据段和 PCB 三部分构成的进程实体
	- 进程映像是静态的，进程是动态的
- 创建进程：创建进程实体中的 PCB 
- 撤销进程：撤销进程的 PCB
- PCB 是进程存在的**唯一标志**
### 特征
进程是由多道程序的并发执行而引出的，它和程序是两个截然不同的概念
1. **动态性**：进程是程序的一次执行，具有一定的生命周期，是动态的
2. **并发性**：指多个进程实体同存于内存中，能在一段时间内同时运行
3. **独立性**：指进程实体是一个能独立运行、独立获得资源和独立接受调度的基本单位
4. **异步性**：由于进程的相互制约，使得进程按各自独立的、不可预知的速度向前推进
## 进程状态转换
![[进程状态图]]
### 基本状态
#### 就绪态
进程获得了除处理机外的一切所需资源，一旦得到处理机，便可立即运行
系统中处于就绪状态的进程可能有多个，通常将它们排成一个队列，称为就绪队列
#### 运行态
进程正在处理机上运行。在单处理机中，每个时刻只有一个进程处于运行态
#### 阻塞态
又称等待态。进程正在等待某一事件而暂停运行，如等待某资源为可用（不包括处理机）或等待输入/输出完成，即使处理机空闲，该进程也不能运行
系统通常将处于阻塞态的进程也排成一个队列，甚至根据阻塞原因的不同，设置多个阻塞队列。
### 其他状态
#### 创建态
进程正在被创建，尚未转到就绪态
1. 申请一个空白 PCB, 并向 PCB 中填写用于控制和管理进程的信息
2. 为该进程分配运行时所必须的资源
3. 把该进程转入就绪态并插入就绪队列。但是，如果进程所需的资源尚不能得到满足，如内存不足，则创建工作尚未完成
#### 结束态
进程正从系统中消失，可能是进程正常结束或其他原因退出运行。进程需要结束运行时，系统首先将该进程置为结束态，然后进一步处理资源释放和回收等工作。
## PCB
### 作用
#### 进程存在的唯一标志
表示多道程序环境下独立运行的、合法的基本单位
#### 实现间断性运行方式
保留 CPU 运行的上下文信息，重新被调度运行时 CPU 根据 PCB 中的信息恢复状态
#### 提供进程管理的所需信息
根据 PCB 中记录的程序和数据在内存或外存中的始址指针，找到相应的程序和数据，或者了解到该进程所需的全部资源
#### 提供进程调度所需要的信息
PCB 提供了进程处于何种状态的信息，为调度提供依据
- 在优先级调度算法中，需要知道进程的优先级
- 在有些较为公平的调度算法中，需要知道进程的等待时间和已执行的时间等
#### 实现与其它进程的同步与通信
PCB 中设有用于同步的信号量，还有用于实现进程通信的区域或通信队列指针等
### 结构
#### 进程标识符
1. 内部标识符 PID，进程在操作系统中唯一的标识
2. 外部标识符，用于描述进程之间的关系（PPID）和 创建者（UID）
#### 处理机信息
存放处理机状态信息，包括
1. 通用寄存器 IR，用于暂存信息
2. 指令计数器 PC，存放下一条指令的地址
3. 程序状态字 PSW，含有状态信息，如条件码、执行方式、中断屏蔽标志等信息
4. 用户/内核栈指针 USP/KSP
	1. 用户栈用于存放用户态时过程和系统调用参数及调用地址，指针指向该栈的栈顶
	2. 内核栈用于存放内核态时系统产生的各种参数和信息
#### 进程调度信息
存放 进程状态、进程优先级、阻塞事件、其他参数，如等待时间等
#### 进程控制信息
是指用于进程控制所必须的信息，包括
1. 程序和数据的地址，进程实体中的程序和数据的内存或外存地(首)址
2. 进程同步和通信机制，如消息队列指针、信号量等
3. 资源分配清单，用于说明有关内存地址空间或虛拟地址空间的状况，所打开文件的列表和所使用的输入/输出设备信息
4. 链接指针，它给出了本进程(PCB)所在队列中的下一个进程的PCB的首地址。
#### 程序段
程序段就是能被进程调度程序调度到 CPU 执行的程序代码段
- 程序可被多个进程共享，即多个进程可以运行同一个程序。
#### 数据段
可以是进程对应的程序加工处理的原始数据，也可以是程序执行时产生的中间或最终结果
## 进程组织
### 线性
根据首地址线性排列，实现简单，但性能差
### 链式
通过 PCB 中的链接字链接，形成就绪队列、多个阻塞队列和空白队列，用于拥塞控制
### 索引
建立专门的索引表
## 进程同步
### 制约关系
#### 同步
直接制约关系，有明确的先后顺序
#### 互斥
间接制约关系，没有明确的先后顺序，需要争抢
### 临界资源
只能同时被一个进程访问的资源，可以是物理设备、数据或者变量
#### 临界区
每个进程中访问临界资源的**代码段**
### 三个条件
#### 互斥
在同一临界区内同时只有一个进程可以执行
#### 前进
如果没有进程在其临界区内执行，且有进程需进入临界区，选择只有那些不在剩余区内执行（**在进入区**）的进程可参加选择，且这种选择不能无限推迟。
#### 有限等待
从一个进程做出进入临界区的请求，直到该请求允许为止，其他进程允许进入其临界区的次数有上限。
### 同步机制遵循的准则
#### 1. 空闲让进
临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区
#### 2. 忙则等待
当已有进程进入临界区时，其他试图进入临界区的进程必须等待
#### 3. 有限等待
对请求访问的进程，应保证能在有限时间内进入临界区
#### 4. 让权等待
当进程不能进入临界区时，应立即释放处理器，防止进程忙等待
### 硬件实现
#### 关中断
在访问临界区前，中断关闭，不会发生进程切换
在访问临界区后，中断开启，其他进程才可以访问临界区
##### 特点
- 单个指令只对单个 CPU 有效，多核会失效
- 需要在内核态运行，所以只有系统进程可以使用
#### TestAndSet(Lock) / SWAP 指令
由硬件实现，循环检查临界区是否加锁，但保证是原子操作
##### 特点
- 适用于多 CPU
- 无法让权等待
### 软件实现
#### 算法
- 单标志法：可能产生死循环
- 双标志法先检查：可能同时访问临界区
- 双标志法后检查：可能产生饥饿现象（都无法进入临界区）
- Peterson 算法：利用 flag 解决临界资源的互斥访问，利用 return 解决“饥饿”现象，但无法**让权等待**
```c
//进程1：
flag[i] = TRUE; turn = j;//进入区
while(flag[j] && turn == j);//进入critical 
section;//临界区
flag[i] = FALSE;//退出区
remainder section;//剩余区

//进程2：
flag[j] = TRUE; turn = i; //进入区
while (flag[i] && turn == i) ; //进入
critical section; //临界区
flag[j] = FALSE; //退出区
remainder section; //剩余区
```
## 信号量✨
两个原语函数：`wait(S)/P(S)`，`signal(S)/V(S)`，使进入区的检查和上锁无法中断
### 整型信号量
S 表示当前系统中资源的数量
- 无法**让权等待**
```c
void wait(S) { //进入区
	while (S <= 0); //资源数量不够，一直循环
	S--; //资源数量够，占用一个资源
}
void signal(S) { //退出区
	S++; //使用完后，释放一个资源
}
```
### 记录型信号量
额外传入等待进程的链表队列，实现**让权等待**
```c
typedef struct {
	int value;
	struct process_control_block *list;
} semaphore;

//初始化
semeaphore mutex = 1

void wait(semaphore S) { //相当于申请资源
	S->value--;
	if (S->value < 0) {
		block(S->list); //添加到等待队列中
	}
}

void signal(semaphore S) { //相当于释放资源
	S->value++;
	if (S->value <= 0) {
		wakeup(S->list); //等待队列中抛出一个进程
	}
}
```
### 实现
#### 进程互斥
`P(mutex)`加锁，`V(mutex)`解锁，**成对出现**，不同的资源要有不同的`mutex`
#### 进程同步
先执行的程序加`V(mutex)`，后执行的程序加`P(mutex)`
#### 前驱关系
每对前驱关系分别设置一个`mutex`，先执行的程序加`V(mutex)`，后执行的程序加`P(mutex)`
## 进程通信（Inter-Process Communication）
简称 IPC
### 类型
#### 共享存储器系统（Shared-memory System） 
##### 共享数据结构
低级共享，由用户控制读写，一般用作缓冲区，传递量少
##### 共享存储区
高级共享，由进程负责，需要进程向操作系统申请，传递量多
#### 管道通信系统（pipe）
半双工通信，写进程将字符写入管道中，读进程读取管道中的数据
```shell
cat test.txt | grep "what"
```
管道机制必须具有
1. 互斥：同时只有一个进程读写管道
2. 同步：只有读写数据时才激活，其余时间在睡眠
3. 只有对方存在才通信
#### 消息传递（Message passing System）
将数据封装进格式化的消息中，利用操作系统提供的原语完成传递
##### 直接通信
通过操作系统发送原语传递消息
##### 间接通信
通过共享中间实体（邮箱）传输
#### 客户机-服务器系统（Clinet-Server System）
socket、RPC
## 线程
### 概念
CPU 的基本执行单元，是系统调度的**基本单位**，不拥有系统资源，但拥有所属进程的所有资源
### 引入目的
更好的并发执行程序，减少进程切换引起的时空开销，提高资源利用效率
### 和进程的区别
1. 线程是独立调度的基本单位，进程是拥有资源的基本单位，同一进程的线程切换不会引起进程切换，不同进程的线程切换会引起进程切换
2. 进程拥有资源，线程不拥有资源但可以访问所属进程的资源
3. 进程只能在一个 CPU 上运行，同个进程的线程可以在多个 CPU 上运行
4. 线程切换的开销小于进程切换的开销
### 组织和控制
线程控制块 TCB 用于记录控制和管理线程的信息
#### 生命周期
创建、阻塞、就绪、运行、终止，和进程类似
#### 用户级线程（User-level Thread）
由程序通过线程库实现，操作系统无法识别
- 优点：不需要切换到内核态，开销小
- 缺点：用户级线程被阻塞后整个进程会被阻塞，并发能力低
#### 内核级线程（Kernel-level Thread）
由操作系统内核完成，操作系统可以识别
- 优点：内核级线程被阻塞后其他线程还可以继续执行，并发能力强
- 缺点：需要切换到内核态，开销大
### 多线程模型
#### 一对一模型
每个用户级线程映射到一个内核级线程
- 优点：当一个线程被阻塞后，允许调度另一个线程运行，所以并发能力较强。
- 缺点：每创建一个用户线程，相应地就需要创建一个内核线程，开销较大。
#### 多对一模型
多个用户级线程映射到一个内核级线程，这些用户线程一般属于一个进程，线程的调度和管理在用户空间完成。仅当用户线程需要访问内核时，才将其映射到一个内核级线程上，但是每次只允许一个线程进行映射。
- 优点：线程管理是在用户空间进行的，因而效率比较髙
- 缺点：如果一个线程在访问内核时发生阻塞，则整个进程都会被阻塞；在任何时刻，只有**一个**线程能够访问内核，多个线程不能同时在多个处理机上运行
#### 多对多模型
n 个用户线程映射到 m 个内核级线程上
- 特点：上述两种优点全占





