---
alias: os-内存管理
tag:
- 829
- 考研
- os
date: 2022年07月21日
---
![[大纲#内存管理]]
## 基本概念
操作系统对内存的划分和动态分配
### 作用
- 方便用户使用存储器、提高内存利用率
	- 通过虚拟技术从逻辑上扩充存储器
### 主要功能
#### 内存空间的分配与回收
由操作系统完成主存储器空间的分配管理，使程序员摆脱存储块分配的麻烦，提高编程效率
#### 地址转换
在多道程序环境下，程序中的逻辑地址与内存中的物理地址不可能一致，因此需要把逻辑地址转换成相应的物理地址
#### 内存空间的扩充
利用虚拟存储技术或自动覆盖技术，从逻辑上扩充内存
#### 内存共享
指允许多个进程访问内存的同一部分
#### 存储保护
保证各道作业在各自的存储空间内运行，互不干扰。
### 程序的链接
创建进程首先要将程序和数据装入内存，需要经过以下几个步骤：
- 编译：由编译程序将用户源代码编译成若干目标模块。
- 链接：由链接程序将编译后形成的一组目标模块及它们所需的库函数链接在一起，形成一个完整的装入模块。
- 装入：由装入程序将装入模块装入内存运行
#### 静态链接
程序运行前将各目标模块及它们所需的库函数链接成一个完整的装配模块
- 编译后的所有目标模块都是从0开始的相对地址，当链接成一个装入模块时修改相对地址
- 每个模块中所用的外部调用符号全都变换为相对地址
#### 装入时动态链接
将编译后的模块在装入内存时边装入边链接
- 便于修改和更新
- 便于实现对目标模块的共享。
#### 运行时动态链接
程序运行时按需链接
- 加快程序的装入过程
- 节省内存空间
### 内存的装入
#### 绝对装入
将程序装入绝对地址，地址可在编译或汇编时给出，也可由程序员直接赋予
- 只适用于单道程序环境
#### 可重定位装入
在多道程序环境下，根据内存的当前情况，将装入模块装入内存的适当位置
- 又称**静态重定位**
- 必须分配全部所需内存空间，不足则无法装入
- 一旦进入内存，运行时不能在内存中移动，不能再申请内存空间
#### 动态运行时装入
运行前只装入部分代码，在运行时按需动态申请分配内存，装入内存后的所有地址均为相对地址
- 又称**动态重定位**
- 可以将程序分配到不连续的存储区
- 便于程序段的共享
### 逻辑地址与物理地址
#### 逻辑地址
编译后，每个目标模块都从0号单元开始编址，这称为该目标模块的逻辑地址
- 进程在运行时，看到和使用的地址都是逻辑地址，用户程序和程序员只需知道逻辑地址
- 不同进程可以有相同的逻辑地址，因为这些相同的逻辑地址可以映射到主存的不同位置。
- 逻辑地址通过页表映射到物理内存， 页表由操作系统维护并被处理器引用
#### 物理地址
是指内存中物理单元的集合，是地址转换的最终地址
- 操作系统通过 MMU 将进程使用的逻辑地址转换为物理地址
### 覆盖与对换
在多道程序环境下用来扩充内存的两种方法。
#### 覆盖
把用户空间分成一个固定区和若干覆盖区。固定区存放经常活跃的部分，覆盖区存放其余部分，每次空间不足时覆盖原有的内容。
- 运行程序的代码量大于主存时不能运行
- 覆盖区中的段会常驻内存
- 对用户和程序员不透明。
#### 交换（SWAP）
把处于等待状态（或在 CPU 调度原则下被剥夺运行权利）的程序从内存移到辅存，需要时再从辅存移到内存
- 备份存储，需要足够大
- I/O时不能交换
- 每个进程的执行时间比交换时间长
- 独立于文件系统
## 内存分配
### 连续内存分配
连续内存分配：是指为一个程序分配一个连续的内存空间。分配方式主要有三种：
#### 单一连续分配
此方式下分为系统区和用户区，低地址的系统区仅供操作系统使用
内存中永远只有一道程序。
##### 优点
- 简单，无外部碎片
- 可采用覆盖技术，不要额外的技术支持
##### 缺点
- 只能用于单任务，单用户的操作系统
- 有内部碎片，存储器利用率极低
#### 固定分区分配
将内存用户空间划分为若干个固定大小的区域，在每个分区中只装入一道作业，允许几道作业并发运行，通常建立一张分区使用表，每个表项包括包括每个分区的起始地址，大小，和状态（是否已分配），当某一用户程序要装入时，由分配程序检索该表，找到一个大小满足且未分配的分区，分配给该程序，并置状态为已分配
##### 缺点
- 程序可能太大而放不进任何一个分区
- 主存利用率低，有**内部碎片**（程序小于固定分区大小也要占用一个完整的分区）
#### 动态分区分配
不预先划分内存，而是在进程装入内存时，根据进程的大小动态的建立分区，并使分区大小刚好适合进程需要
- 随着时间推移内存中会出现**外部碎片**（在所有分区的外部，无法被利用）
	- 克服外部碎片可以采用紧凑技术
##### 分配策略
进程装入或换入时，需要确定分配哪个内存块给进程
- 首次适应算法：顺序查找
- 临近适应算法：循环首次适应算法，从上次结束的位置顺序查找
- 最佳适应算法：分配容量大小最接近且能满足需要的空闲分区
- 最坏适应算法：分配容量最大的空闲分区，并分割出需要的大小
分配内存时从上次查找结束的位置开始查找）
#### 可重定位分区分配
每次找不到足够大的空闲分区，就先“紧凑”内存，然后再分配
### 离散内存分配
允许一个程序分散的装入不相邻的内存分区
#### 基本分页存储管理
- 页：分页存储管理将一个**进程的逻辑地址空间**分成若干个大小相等的片
- 物理块或页框：把**内存空间**分成与页面大小相等的若干个储存块
- 页表：实现页号到物理块号的地址映射。
##### 访存
两次访存
- 第一次访存：查内存中的页表
- 第二次访存：访问目标内存单元
#### 基本分段存储管理
满足程序员在编程和使用上的诸多要求：
1. 方便编程
2. 信息共享
3. 信息保护
4. 动态增长
5. 动态链接
##### 访存
两次访存
- 第一次访存：查内存中的段表
- 第二次访存：访问目标内存单元。
#### 分段和分页的主要区别
- 分页是信息的物理单位，段是信息的逻辑单位
- 页的大小固定且由系统固定，段的长度不固定，决定于用户编写程序的长度
- 分页的作业地址空间是一维的，程序员只用一个记忆符即可表示一个地址；分段的地址空间是二维的，程序员在表示一个地址时，既需要给出段名又需要给出段内地址
#### 段页式存储管理
分段与分页管理相结合，先将用程序分为若干段，再把每个段分为若干个页，地址结构由段号，段内页号，页内地址组成
##### 地址变换过程
配置一个段表寄存器，其中存放段表始址和段表长。进行地址变换时，先将段号与段表长比较，若小于段表长，表示未越界，于是利用段表始址和段号求出该段所对应的段表项在段表中的位置，从中得到该段的页表始址，并利用段内页号来获得对应的页表项位置，从中得出该页所在的物理块号，在利用块号和页内地址构成物理地址。
- 三次访问内存
### 区别

|                  | 分页                                                                                                                       | 分段                                                                                              |
| ---------------- | -------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------- |
| 目的             | 页是信息的物理单位，分页是为实现离散分配方式，以消减内存的外零头，提髙内存的利用率。                                       | 是信息的逻辑单位，它含有一组其意义相对完整的信息。分段的目的是为了能更好地满足用户的需要          |
| 长度             | 页的大小固定且由系统决定，由系统把逻辑地址划分为页号和页内地址两部分，是由机器硬件实现的，因而在系统中只能有一种大小的页面 | 段的长度不固定，决定于用户所编写的程序， 通常由编译程序在对流程序进行编译时，根据信息的性质来划分 |
| 地址空间         | 分页地址空间是一维的，即单一的线性地址空间，程序员只需利用一个记忆符，即可表示一个地址                                     | 分段地址空间是二维的，程序员在标识一个地址时，既需给出段名，又需给出段内地址                      |
| 碎片             | 有内部碎片，无外部碎片                                                                                                     | 有外部碎片，无内部碎片                                                                            |
| 共享 和 动态链接 | 不容易实现                                                                                                                 | 容易实现                                                                                          | 

## 虚拟内存分配
### 虚拟存储器
指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统。
### 局部性原理
#### 时间局部性
指令被执行过后很有可能在之后再次被访问，如程序中存在大量的循环操作
#### 空间局部性
数据被访问过后很有可能地址附近的数据也会被访问，如程序中的数组
### 特征
1. 多次性
2. 对换性
3. 虚拟性
### 地址计算
- 页号 = 逻辑地址 / 页长
- 业内地址 = 逻辑地址 % 页长
### 软硬件支持
#### 请求分页管理
##### 硬件支持
1. 一定容量的内存和外存
2. 页表机制
3. 中断机构
4. 地址变换机构 
##### 软件支持
1. 实现请求调页的软件
2. 实现页面置换的软件
#### 请求分段管理
##### 硬件支持
1. 一定容量的内存和外存
2. 段表机制
3. 中断机构
4. 地址变换机构 
##### 软件支持
1. 实现请求调段的软件
2. 实现段置换的软件
### 请求分页（段）管理
#### 页表机制
页表除了含有页号及其对对应的物理块号以外，还有
- 状态位：用于指示该页是否调入内存
- 访问字段：记录一段时间内被访问次数
- 修改位：表示该页在调入内存后是否被修改过
#### 缺页中断机构
缺页中断是一种特殊的中断，区别：
1. 指令执行期间产生和处理中断信号
2. 一条指令执行期间，可能产生多次缺页中断
#### 地址变换机构
![[4.内存管理-20220722.png]]
1. 只有写指令才需要修改“修改位”。并且，一般来说只需修改快表中的数据，只有要将快表项删除时才需要写回内存中的慢表，这样可以减少访存次数
2. 和普通的中断处理一样，缺页中断处理依然需要保留 CPU 现场
3. 换入/换出页面都需要启动慢速的 I/O 操作，可见，如果换入/换出太频繁，会有很大的开销
4. 页面调入内存后，需要修改慢表，同时也需要将表项复制到快表中
#### 物理块的分配策略
1. 固定分配局部置换
2. 可变分配全局置换
3. 可变分配局部置换
#### 调入页面的时机
1. 预调页策略
2. 请求调页策略（每次调入一页）
### 页面置换算法✨
#### 最佳置换算法（opt）
淘汰最长时间未使用的页面
- 性能最佳
- 不可能实现
#### 先进先出页面置换算法（FIFO）
淘汰最先进入的页面
- 实现简单
- 出现 Belady 异常：块数增大，换页率也增大
#### 最近最久未使用置换算法（LRU）
淘汰最近最久未使用的页面
- 从当前时间往前看，最后一个出现的当前页淘汰
- 性能很好
- 需要硬件支持，算法开销大
#### 时钟置换算法（CLOCK）
设置**访问位**，记录是否被访问
先全置为0，访问后置为1，换页时扫描，扫描到的位置为0，都为1则继续循环扫描，换掉最先=0的页面后停止
- 最多两轮
- 开销小，未优化
#### 改进型 clock 置换算法
设置**访问位**和**修改位**，记录是否被访问和修改，记为（访问位，修改位）
- 第一轮：从当前位置开始扫描到第一个（0，0）的帧用于替换
	- 本轮扫描不修改任何标志位
	- 没访问，没修改
- 第二轮：若第一轮扫描失败，则重新扫描，查找第一个（0，1）的帧用于替换
	- 本轮将所有扫描过的帧访问位设为0
	- 没访问，修改过
- 第三轮：若第二轮扫描失败，则重新扫描，查找第一个（0，0）的帧用于替换
	- 本轮扫描不修改任何标志位
	- 访问过，没修改
- 第四轮：若第三轮扫描失败，则重新扫描，查找第一个（0，1）的帧用于替换
	- 访问过，修改过
#### 例题
考虑下述页面走向：
1，2，3，4，2，1，5，6，2，1，2，3，7，6，3，2，1，2，3，6
当内存块数量分别为3时（或者说是页框数是3，或者说帧数是3），试问FIFO、LRU、OPT这三种置换算法的缺页次数各是多少，缺页中断率是多少？

| FIFO | 1     | 2     | 3     | 4     | 2   | 1     | 5     | 6     | 2     | 1     | 2   | 3     | 7     | 6     | 3   | 2     | 1     | 2   | 3     | 6     |
| ---- | ----- | ----- | ----- | ----- | --- | ----- | ----- | ----- | ----- | ----- | --- | ----- | ----- | ----- | --- | ----- | ----- | --- | ----- | ----- |
| 1    | **1** | 1     | 1     | **4** | 4   | 4     | 4     | **6** | 6     | 6     | 6   | **3** | 3     | 3     | 3   | **2** | 2     | 2   | 2     | **6** |
| 2    |       | **2** | 2     | 2     | 2   | **1** | 1     | 1     | **2** | 2     | 2   | 2     | **7** | 7     | 7   | 7     | **1** | 1   | 1     | 1     |
| 3    |       |       | **3** | 3     | 3   | 3     | **5** | 5     | 5     | **1** | 1   | 1     | 1     | **6** | 6   | 6     | 6     | 6   | **3** | 3     |

| OPT | 1     | 2     | 3     | 4     | 2   | 1   | 5     | 6     | 2   | 1   | 2   | 3     | 7     | 6   | 3   | 2     | 1     | 2   | 3   | 6     |
| --- | ----- | ----- | ----- | ----- | --- | --- | ----- | ----- | --- | --- | --- | ----- | ----- | --- | --- | ----- | ----- | --- | --- | ----- |
| 1   | **1** | 1     | 1     | 1     | 1   | 1   | 1     | 1     | 1   | 1   | 1   | **3** | 3     | 3   | 3   | 3     | 3     | 3   | 3   | 3     |
| 2   |       | **2** | 2     | 2     | 2   | 2   | 2     | 2     | 2   | 2   | 2   | 2     | **7** | 7   | 7   | **2** | 2     | 2   | 2   | 2     |
| 3   |       |       | **3** | **4** | 4   | 4   | **5** | **6** | 6   | 6   | 6   | 6     | 6     | 6   | 6   | 6     | **1** | 1   | 1   | **6** |

| LRU | 1     | 2     | 3     | 4     | 2   | 1     | 5     | 6     | 2     | 1     | 2   | 3     | 7     | 6     | 3   | 2     | 1     | 2   | 3   | 6     |
| --- | ----- | ----- | ----- | ----- | --- | ----- | ----- | ----- | ----- | ----- | --- | ----- | ----- | ----- | --- | ----- | ----- | --- | --- | ----- |
| 1   | **1** | 1     | 1     | **4** | 4   | 4     | **5** | 5     | 5     | **1** | 1   | 1     | **7** | 7     | 7   | **2** | 2     | 2   | 2   | 2     |
| 2   |       | **2** | 2     | 2     | 2   | 2     | 2     | **6** | 6     | 6     | 6   | **3** | 3     | 3     | 3   | 3     | 3     | 3   | 3   | 3     |
| 3   |       |       | **3** | 3     | 3   | **1** | 1     | 1     | **2** | 2     | 2   | 2     | 2     | **6** | 6   | 6     | **1** | 1   | 1   | **6** |

| 算法 | 缺页次数 | 缺页中断率 |
| ---- | -------- | ---------- |
| FIFO | **16**   | **80%**    |
| OPT  | **11**   | **55%**    |
| LRU  | **15**   | **75%**    |

### 内存保护
保护操作系统不受用户进程的影响，同时保护用户进程不受其他用户进程的影响。
1. 设置一存取控制字段，用于对该存储块中的内容加以保护。当存取控制字段仅有一位时，可用来规定该存储块中的内容是允许读/写，还是只读；若存取控制字段为二位，则可规定为读/写、只读和只执行等存取方式。如果有一进程试图去写一个只允许读的存储块时，将引起操作系统的一次中断
2. 在 CPU 设置一对上下限寄存器，存放用户作业在主存中的上限和下限地址，每当 CPU 访问一个地址时，分别和两个寄存器的值比较，判断有无越界。
3. 采用重定位寄存器（基址寄存器）和界地址寄存器（限长寄存器）。重定位寄存器含有最小的物理地址值，界地址寄存器含逻辑地址最大值。每个逻辑地址必须小于界地址寄存器，内存管理机构动态的将逻辑地址与界地址寄存器进行比较，若未发生地址越界，则加上重定位地址寄存器的值形成物理地址。（重定位寄存器用来加，界地址寄存器用来比）
### 内存共享
#### 基本分段
分段系统的一个突出优点，是易于实现段的共享，即允许若干个进程共享一个或多个分段，且对段的保护也十分简单易行。可重入代码(Reentrant Code)又称为“纯代码”(Pure Code)，是一种允许多个进程同时访问的代码。为使各个进程所执行的代码完全相同，绝对不允许可重入代码在执行中有任何
改变。
#### 请求分段
为了实现分段共享，可在系统中配置一张共享段表，所有各共享段都在共享段表中占有一表项。表项中记录了共享段的段号、段长、内存始址、存在位等信息，并记录了共享此分段的每个进程的情况。
## 抖动
### 概念
刚刚换出的页面马上就要换入主存，刚刚换入的页面马上就要换出主存
### 原因
某个进程频繁访问的页面数目高于可用的物理页帧数8ui9tgokjn;.bm /,'0n.bui9t目
### 处理方法
1. 采用工作集
2. 采用局部置换
3. 使 缺页间的平均时间 = 换页时间
4. 暂停某些进程




