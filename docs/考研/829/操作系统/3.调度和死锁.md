---
alias: os-调度&死锁
tag:
- 考研 
- 829
- os
date: 2022年07月20日
---
![[大纲#调度与死锁]]
## 调度
### 概念
从就绪队列中按照一定的算法（公平、高效的原则）选择一个进程并将其处理机分配给运行，以实现进程并发地执行
### 调度的3个层次
#### 高级调度（作业调度）
按照一定的原则从**外存**上处于后备队列的作业中挑选一个（或多个），给它（们）分配内存、输入/输出设备等必要的资源，并建立相应的进程，将其放入就绪队列中
#### 中级调度（内存调度）
提高内存利用率和系统吞吐量，将暂时不能运行的进程调至外存等待，此时进程的状态称为挂起态
#### 低级调度（进程调度）
按照某种算法从就绪队列中选取一个进程，将处理机分配给它
### 算法
#### 先到先服务 FCFS
就绪队列中**先到达**的进程先执行
#### 短作业优先 JSF
就绪队列中**时间短**的先执行
##### 抢占 SRTF
- 进程到达时，比较**当前进程的剩余所需时间**和**新进程的所需时间**，时间短的先执行，一样长就不换。
- 进程结束时，选择当前队列中需要时间**最短**的进程执行
#### 时间片调度 RR
按照**时间片**将进程分割，当前时间片结束的进程放到队列最后
- 进程结束时间片未用完，则直接当用完处理
#### 多级反馈队列调度 MFQ
设置多个就绪队列，设置不同的优先级和时间片长度，优先级越高先执行
## 死锁
### 概念
多个进程因竞争资源而互相等待，若无外力作用，这些进程都将无法继续执行
### 产生原因
1. 竞争的资源不可剥夺
2. 进程间推进顺序非法
### 必要条件
#### 互斥
一段时间内某资源只能有一个进程占用
#### 请求和保持
进程保持了一个资源又申请新的资源，但该资源被另外进程占用，此时该进程进入阻塞态，但不释放已申请的资源
#### 不可抢占
进程使用的资源不能被剥夺，只能在使用完后释放
#### 循环等待
进程-资源的图存在环
### 处理
### 预防
#### 破坏“互斥”
不可行，一些数据和设备不能同时使用
#### 破坏“请求和保持”
不可行，虽然保证不会产生死锁，但是严重的资源浪费，甚至饥饿
#### 破坏“不可抢占”
不可行，会导致前阶段的工作失效，反复申请资源，增加系统开销
#### 破坏“循环等待”
不可行，必须按编号请求会导致资源浪费和编程困难
### 避免
#### 安全状态
系统动态的分配资源，如果本次分配资源会导致系统进入不安全的状态（找不到安全序列），则不进行分配
- 安全序列：能够不产生死锁的进程队列
- 安全序列可能有多个
#### 银行家算法
同上的思想
给定可分配的资源、最大资源需求量 `Max`、已分配的资源 `Work`
有时候 `Need` 需要通过 `Max - Work` 计算
![[3.调度和死锁-20220720-1.png]]
判断分配之后 `Max` 能否满足其他的 `Need`，满足就分配
### 检测
#### 资源分配图
- 两种结点
	- 进程结点：对应一个进程
	- 资源结点：对应一类资源，一类资源可能有多个
- 两种边
	- 进程结点->资源结点：表示进程想申请几个资源（每条边代表一个）
	- 资源节点->进程结点：表示已经为进程分配了几个资源（每条边代表一个）
![[3.调度和死锁-20220720.png]]
能消去的边，该进程不会被死锁
不能简化时剩余的边会导致死锁
### 解除
#### 资源剥夺法
挂起死锁进程，但不能长时间挂起
#### 进程撤销法
强制撤销死锁的进程，可以按照进程优先级和撤销代价进行
#### 进程回退法
让进程回退至足以回避死锁的程度，并保留进程的历史信息，设置还原点
### 例题
某系统中有M台打印机，n个进程共享打印机资源，每个进程要求k台。M的取值至少应为$k(n-1)+1$，系统不会发生死锁


